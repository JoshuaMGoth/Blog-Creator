const express = require('express');
const exphbs = require('express-handlebars');
const path = require('path');
const fs = require('fs-extra');
const axios = require('axios');
const multer = require('multer');

const app = express();
const PORT = process.env.PORT || 3030;

// Setup Handlebars
app.engine('handlebars', exphbs.engine({
    defaultLayout: 'main',
    runtimeOptions: {
        allowProtoPropertiesByDefault: true,
        allowProtoMethodsByDefault: true
    },
    helpers: {
        json: function(context) {
            return JSON.stringify(context);
        }
    }
}));
app.set('view engine', 'handlebars');
app.set('views', path.join(__dirname, 'views'));

// Create necessary directories
const dirs = ['views/layouts', 'views/partials', 'public', 'config', 'blogs', 'temp'];
dirs.forEach(dir => {
    fs.ensureDirSync(path.join(__dirname, dir));
});

// Configure multer for file uploads
const storage = multer.diskStorage({
    destination: function(req, file, cb) {
        const tempDir = path.join(__dirname, 'temp');
        fs.ensureDirSync(tempDir);
        cb(null, tempDir);
    },
    filename: function(req, file, cb) {
        const uniqueName = Date.now() + '-' + Math.round(Math.random() * 1E9) + path.extname(file.originalname);
        cb(null, uniqueName);
    }
});

const upload = multer({ 
    storage: storage,
    limits: { fileSize: 10 * 1024 * 1024 }, // 10MB limit
    fileFilter: function(req, file, cb) {
        const allowedTypes = /jpeg|jpg|png|gif|webp|svg/;
        const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());
        const mimetype = allowedTypes.test(file.mimetype);
        
        if (mimetype && extname) {
            return cb(null, true);
        } else {
            cb(new Error('Only image files are allowed (JPEG, PNG, GIF, WEBP, SVG)!'));
        }
    }
});

// Middleware - ADD CSP headers that allow inline scripts
app.use((req, res, next) => {
    res.setHeader(
        'Content-Security-Policy',
        "default-src 'self'; script-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com; style-src 'self' 'unsafe-inline' https://cdnjs.cloudflare.com https://fonts.googleapis.com; font-src 'self' https://cdnjs.cloudflare.com https://fonts.gstatic.com; img-src 'self' data: blob:;"
    );
    next();
});

app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(express.static('public'));

// Serve uploaded images
app.use('/uploads', express.static(path.join(__dirname, 'temp')));

// Configuration file path
const configPath = path.join(__dirname, 'config', 'settings.json');

// Helper function to get config
function getConfig() {
    try {
        if (fs.existsSync(configPath)) {
            return JSON.parse(fs.readFileSync(configPath, 'utf8'));
        }
    } catch (error) {
        console.error('Error reading config:', error);
    }
    return {
        deepseekApiKey: '',
        imageAiApiKey: '',
        hugoPath: '',
        frontMatter: {
            title: '',
            date: '{{date}}',
            draft: true,
            tags: [],
            categories: [],
            featuredImage: ''
        },
        sftp: {
            host: '',
            port: 22,
            username: '',
            password: '',
            remotePath: ''
        },
        theme: 'light'
    };
}

// Helper function to save config
function saveConfig(config) {
    try {
        fs.writeFileSync(configPath, JSON.stringify(config, null, 2));
        return true;
    } catch (error) {
        console.error('Error saving config:', error);
        return false;
    }
}

// Routes
app.get('/', (req, res) => {
    const config = getConfig();
    res.render('index', {
        title: 'Blog Creator Pro',
        config: config,
        blogTypes: [
            { value: 'instructional', label: 'Instructional', icon: 'fas fa-graduation-cap' },
            { value: 'personable', label: 'Personal', icon: 'fas fa-user-circle' },
            { value: 'story', label: 'Story', icon: 'fas fa-book' },
            { value: 'informative', label: 'Informative', icon: 'fas fa-chart-bar' },
            { value: 'persuasive', label: 'Persuasive', icon: 'fas fa-bullhorn' }
        ],
        voices: [
            { value: 'inspirational', label: 'Inspirational', icon: 'fas fa-star' },
            { value: 'serious', label: 'Serious', icon: 'fas fa-balance-scale' },
            { value: 'casual', label: 'Casual', icon: 'fas fa-coffee' },
            { value: 'humorous', label: 'Humorous', icon: 'fas fa-laugh' },
            { value: 'empathetic', label: 'Empathetic', icon: 'fas fa-heart' }
        ]
    });
});

app.get('/settings', (req, res) => {
    const config = getConfig();
    res.render('settings', {
        title: 'Settings',
        config: config,
        success: req.query.success === 'true',
        error: req.query.error === 'true'
    });
});

app.post('/settings', (req, res) => {
    try {
        const config = getConfig();
        
        // Update config with form data
        config.deepseekApiKey = req.body.deepseekApiKey || '';
        config.imageAiApiKey = req.body.imageAiApiKey || '';
        config.hugoPath = req.body.hugoPath || '';
        config.theme = req.body.theme || 'light';
        
        // Front matter
        config.frontMatter = {
            title: req.body.title || '',
            date: '{{date}}',
            draft: req.body.draft === 'true',
            tags: (req.body.tags || '').split(',').map(tag => tag.trim()).filter(tag => tag),
            categories: (req.body.categories || '').split(',').map(cat => cat.trim()).filter(cat => cat),
            featuredImage: ''
        };
        
        // SFTP settings
        config.sftp = {
            host: req.body.host || '',
            port: req.body.port || 22,
            username: req.body.username || '',
            password: req.body.password || '',
            remotePath: req.body.remotePath || ''
        };
        
        if (saveConfig(config)) {
            res.redirect('/settings?success=true');
        } else {
            res.redirect('/settings?error=true');
        }
    } catch (error) {
        console.error('Error saving settings:', error);
        res.redirect('/settings?error=true');
    }
});

// Generate blog content using DeepSeek API
async function generateWithDeepSeek(prompt, apiKey) {
    try {
        console.log('Sending request to DeepSeek API...');
        console.log('Prompt length:', prompt.length);
        
        const response = await axios.post(
            'https://api.deepseek.com/chat/completions',
            {
                model: 'deepseek-chat',
                messages: [
                    { 
                        role: 'system', 
                        content: 'You are a professional blog writer. Write engaging, human-like blog content with natural flow and varied sentence structures. Respond with well-formatted markdown including headings, paragraphs, and lists where appropriate.'
                    },
                    { 
                        role: 'user', 
                        content: prompt 
                    }
                ],
                max_tokens: 1500,
                temperature: 0.7,
                stream: false
            },
            {
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                timeout: 120000,
                maxContentLength: Infinity,
                maxBodyLength: Infinity
            }
        );
        
        console.log('DeepSeek API Response received');
        return response.data.choices[0].message.content;
    } catch (error) {
        console.error('DeepSeek API Error Details:');
        console.error('- Status:', error.response?.status);
        console.error('- Message:', error.response?.data?.error?.message || error.message);
        
        if (error.code === 'ECONNABORTED') {
            throw new Error('DeepSeek API request timed out. Please try again.');
        } else if (error.response?.status === 401) {
            throw new Error('Invalid DeepSeek API key. Please check your API key in Settings.');
        } else if (error.response?.status === 429) {
            throw new Error('Rate limit exceeded. Please wait a moment and try again.');
        } else if (error.response?.data?.error?.message) {
            throw new Error(`DeepSeek API Error: ${error.response.data.error.message}`);
        } else {
            throw new Error(`DeepSeek API Error: ${error.message}`);
        }
    }
}

// Spell and grammar correction using DeepSeek API
async function correctSpellingGrammar(text, apiKey) {
    try {
        console.log('Correcting spelling and grammar...');
        
        const response = await axios.post(
            'https://api.deepseek.com/chat/completions',
            {
                model: 'deepseek-chat',
                messages: [
                    { 
                        role: 'system', 
                        content: 'You are a professional editor. Correct ONLY spelling and grammar errors in the provided text. Do NOT rewrite or change the meaning. Do NOT add new content. Do NOT change the style or tone. Only fix spelling mistakes and grammar errors. Return the corrected text exactly as provided, with only the necessary corrections.'
                    },
                    { 
                        role: 'user', 
                        content: `Please correct ONLY spelling and grammar errors in this text. Do not change anything else:\n\n${text}`
                    }
                ],
                max_tokens: Math.min(text.length * 2, 4000),
                temperature: 0.3,
                stream: false
            },
            {
                headers: {
                    'Authorization': `Bearer ${apiKey}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                },
                timeout: 60000
            }
        );
        
        console.log('Spell/grammar correction complete');
        return response.data.choices[0].message.content;
    } catch (error) {
        console.error('Correction API Error:', error.message);
        throw new Error(`Spell/grammar correction failed: ${error.message}`);
    }
}

// Create blog prompt based on selections
function createBlogPrompt(topic, blogType, voice, additionalInstructions) {
    const prompts = {
        instructional: `Write a detailed instructional blog post about "${topic}". Provide step-by-step guidance, practical tips, and actionable advice. Use clear headings and bullet points where appropriate. Aim for about 800-1000 words.`,
        personable: `Write a personal and engaging blog post about "${topic}". Share personal experiences, anecdotes, and insights in a conversational tone. Make it relatable and authentic. Aim for about 800-1000 words.`,
        story: `Write a compelling narrative blog post about "${topic}". Create a story that captivates readers with characters, plot, and emotional depth. Use descriptive language. Aim for about 800-1000 words.`,
        informative: `Write an informative and well-researched blog post about "${topic}". Provide facts, data, and analysis while keeping it accessible and engaging. Aim for about 800-1000 words.`,
        persuasive: `Write a persuasive blog post about "${topic}". Use compelling arguments, evidence, and rhetorical strategies to convince readers. Aim for about 800-1000 words.`
    };
    
    const voices = {
        inspirational: 'Use an inspirational and motivational tone that uplifts and encourages readers.',
        serious: 'Use a serious, professional, and authoritative tone suitable for expert audiences.',
        casual: 'Use a casual, friendly, and relaxed tone as if talking to a friend.',
        humorous: 'Use a humorous and witty tone with appropriate jokes and lighthearted observations.',
        empathetic: 'Use an empathetic, understanding, and compassionate tone that connects emotionally.'
    };
    
    const basePrompt = prompts[blogType] || prompts.informative;
    const voicePrompt = voices[voice] || voices.casual;
    
    let prompt = `${basePrompt} ${voicePrompt}.`;
    
    if (additionalInstructions && additionalInstructions.trim()) {
        prompt += ` Additional instructions: ${additionalInstructions}`;
    }
    
    prompt += ` Make the content sound human, avoid repetitive structures, and ensure uniqueness. Include markdown formatting with headings, lists, and emphasis where appropriate.`;
    
    return prompt;
}

// Generate slug from title
function generateSlug(text) {
    return text
        .toLowerCase()
        .replace(/[^\w\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/--+/g, '-')
        .trim();
}

// Extract front matter from markdown
function extractFrontMatter(markdown) {
    const frontMatter = {};
    const lines = markdown.split('\n');
    
    if (lines[0] === '---') {
        let i = 1;
        while (i < lines.length && lines[i] !== '---') {
            const line = lines[i];
            const colonIndex = line.indexOf(':');
            if (colonIndex > -1) {
                const key = line.substring(0, colonIndex).trim();
                let value = line.substring(colonIndex + 1).trim();
                
                // Handle array values
                if (value.startsWith('[') && value.endsWith(']')) {
                    value = JSON.parse(value);
                } else if (value === 'true' || value === 'false') {
                    value = value === 'true';
                }
                
                frontMatter[key] = value;
            }
            i++;
        }
    }
    
    return frontMatter;
}

// Create markdown content with front matter
function createMarkdown(frontMatter, content) {
    let markdown = '---\n';
    
    for (const [key, value] of Object.entries(frontMatter)) {
        if (Array.isArray(value)) {
            markdown += `${key}:\n`;
            value.forEach(item => {
                markdown += `  - ${item}\n`;
            });
        } else if (typeof value === 'boolean') {
            markdown += `${key}: ${value}\n`;
        } else {
            markdown += `${key}: ${value}\n`;
        }
    }
    
    markdown += '---\n\n';
    markdown += content;
    
    return markdown;
}

// API test endpoint
app.post('/api/test', async (req, res) => {
    const config = getConfig();
    
    const results = {
        deepseek: { success: false, message: '' },
        hugo: { success: false, message: '' }
    };
    
    try {
        // Test DeepSeek API
        if (config.deepseekApiKey && config.deepseekApiKey.trim()) {
            const response = await axios.post(
                'https://api.deepseek.com/chat/completions',
                {
                    model: 'deepseek-chat',
                    messages: [{ role: 'user', content: 'Test connection - respond with "OK"' }],
                    max_tokens: 10,
                    temperature: 0.1
                },
                {
                    headers: {
                        'Authorization': `Bearer ${config.deepseekApiKey}`,
                        'Content-Type': 'application/json'
                    },
                    timeout: 15000
                }
            );
            results.deepseek = { 
                success: true, 
                message: 'DeepSeek API connected successfully' 
            };
        } else {
            results.deepseek = { 
                success: false, 
                message: 'DeepSeek API key not configured' 
            };
        }
        
        // Test Hugo path
        if (config.hugoPath && config.hugoPath.trim()) {
            if (fs.existsSync(config.hugoPath)) {
                // Check if it looks like a Hugo directory
                const hasConfig = fs.existsSync(path.join(config.hugoPath, 'config.toml')) || 
                                 fs.existsSync(path.join(config.hugoPath, 'config.yaml')) ||
                                 fs.existsSync(path.join(config.hugoPath, 'config.yml'));
                
                if (hasConfig) {
                    results.hugo = { 
                        success: true, 
                        message: 'Hugo project found and looks valid' 
                    };
                } else {
                    results.hugo = { 
                        success: false, 
                        message: 'Directory exists but does not appear to be a Hugo project (no config file found)' 
                    };
                }
            } else {
                results.hugo = { 
                    success: false, 
                    message: 'Hugo path does not exist' 
                };
            }
        } else {
            results.hugo = { 
                success: false, 
                message: 'Hugo path not configured' 
            };
        }
        
        const allSuccess = results.deepseek.success && results.hugo.success;
        const message = allSuccess 
            ? 'All tests passed!' 
            : `Test results: ${results.deepseek.message}, ${results.hugo.message}`;
            
        res.json({ 
            success: allSuccess, 
            message: message,
            results: results
        });
        
    } catch (error) {
        console.error('Test error:', error.message);
        
        let errorMessage = `Test failed: ${error.message}`;
        if (error.response?.status === 401) {
            errorMessage = 'Invalid DeepSeek API key. Please check your API key in Settings.';
        } else if (error.code === 'ECONNABORTED') {
            errorMessage = 'Connection timeout. Please check your internet connection.';
        }
        
        res.json({ 
            success: false, 
            message: errorMessage,
            results: results
        });
    }
});

// Upload image endpoint
app.post('/api/upload-image', upload.single('image'), async (req, res) => {
    try {
        if (!req.file) {
            return res.json({ 
                success: false, 
                message: 'No image file uploaded' 
            });
        }
        
        console.log('Image uploaded:', req.file.filename);
        
        res.json({
            success: true,
            message: 'Image uploaded successfully',
            filename: req.file.filename,
            path: `/uploads/${req.file.filename}`,
            size: req.file.size,
            mimetype: req.file.mimetype
        });
        
    } catch (error) {
        console.error('Image upload error:', error);
        res.json({ 
            success: false, 
            message: `Image upload failed: ${error.message}` 
        });
    }
});

// Spell and grammar correction endpoint
app.post('/api/correct-text', async (req, res) => {
    const { text } = req.body;
    const config = getConfig();
    
    if (!config.deepseekApiKey || !config.deepseekApiKey.trim()) {
        return res.json({ 
            success: false, 
            message: 'DeepSeek API key not configured. Please go to Settings and add your API key.' 
        });
    }
    
    if (!text || !text.trim()) {
        return res.json({ 
            success: false, 
            message: 'Please provide text to correct' 
        });
    }
    
    try {
        const correctedText = await correctSpellingGrammar(text, config.deepseekApiKey);
        
        res.json({
            success: true,
            message: 'Text corrected successfully',
            original: text,
            corrected: correctedText
        });
        
    } catch (error) {
        console.error('Correction error:', error.message);
        res.json({ 
            success: false, 
            message: `Correction failed: ${error.message}` 
        });
    }
});

// Generate blog endpoint
app.post('/api/generate-blog', async (req, res) => {
    const { topic, blogType, voice, additionalInstructions, imageFilename } = req.body;
    const config = getConfig();
    
    if (!config.deepseekApiKey || !config.deepseekApiKey.trim()) {
        return res.json({ 
            success: false, 
            message: 'DeepSeek API key not configured. Please go to Settings and add your API key.' 
        });
    }
    
    if (!topic || !topic.trim()) {
        return res.json({ 
            success: false, 
            message: 'Please enter a blog topic' 
        });
    }
    
    try {
        // Create prompt
        const prompt = createBlogPrompt(topic, blogType, voice, additionalInstructions);
        console.log('Generating blog with prompt length:', prompt.length);
        
        // Generate content using DeepSeek API
        const content = await generateWithDeepSeek(prompt, config.deepseekApiKey);
        
        // Create blog structure
        const blogId = generateSlug(topic) + '-' + Date.now();
        const blogDir = path.join(__dirname, 'blogs', blogId);
        fs.ensureDirSync(blogDir);
        
        // Handle image if provided
        let featuredImage = '';
        if (imageFilename && imageFilename.trim()) {
            const tempImagePath = path.join(__dirname, 'temp', imageFilename);
            if (fs.existsSync(tempImagePath)) {
                const imageExt = path.extname(imageFilename);
                const blogImageName = `featured${imageExt}`;
                const blogImagePath = path.join(blogDir, blogImageName);
                
                // Copy image to blog directory
                fs.copySync(tempImagePath, blogImagePath);
                featuredImage = blogImageName;
                console.log('Image copied to blog directory:', blogImagePath);
            }
        }
        
        // Create front matter
        const frontMatter = {
            ...config.frontMatter,
            title: topic,
            date: new Date().toISOString(),
            draft: false
        };
        
        // Add featured image to front matter if exists
        if (featuredImage) {
            frontMatter.featuredImage = featuredImage;
            frontMatter.image = featuredImage;
        }
        
        // Create markdown content
        const markdownContent = createMarkdown(frontMatter, content);
        
        // Save blog
        const blogPath = path.join(blogDir, 'index.md');
        fs.writeFileSync(blogPath, markdownContent);
        
        // If Hugo path is set, copy to Hugo content directory
        if (config.hugoPath && config.hugoPath.trim() && fs.existsSync(config.hugoPath)) {
            const hugoContentPath = path.join(config.hugoPath, 'content', 'posts', blogId);
            fs.ensureDirSync(hugoContentPath);
            
            // Copy all files from blog directory to Hugo directory
            fs.copySync(blogDir, hugoContentPath);
            console.log('Blog copied to Hugo content directory:', hugoContentPath);
        }
        
        console.log('Blog generated successfully:', blogPath);
        
        res.json({
            success: true,
            message: 'Blog generated successfully!',
            blogId: blogId,
            content: markdownContent,
            path: blogPath,
            featuredImage: featuredImage ? `/blogs/${blogId}/${featuredImage}` : null
        });
        
    } catch (error) {
        console.error('Error generating blog:', error.message);
        res.json({ 
            success: false, 
            message: `Error generating blog: ${error.message}` 
        });
    }
});

// Upload to server endpoint
app.post('/api/upload-server', async (req, res) => {
    const config = getConfig();
    
    if (!config.hugoPath || !config.hugoPath.trim()) {
        return res.json({ 
            success: false, 
            message: 'Hugo path not configured. Please set it in Settings.' 
        });
    }
    
    try {
        // Execute Hugo build command
        const { exec } = require('child_process');
        const util = require('util');
        const execPromise = util.promisify(exec);
        
        console.log('Building Hugo site...');
        const { stdout: hugoOutput, stderr: hugoError } = await execPromise(
            `cd "${config.hugoPath}" && hugo`,
            { timeout: 60000 }
        );
        
        if (hugoError && !hugoError.includes('warning')) {
            throw new Error(`Hugo build error: ${hugoError}`);
        }
        
        // Check if SFTP is configured
        if (!config.sftp.host || !config.sftp.username) {
            return res.json({ 
                success: true, 
                message: 'Hugo site built successfully. SFTP not configured for deployment.' 
            });
        }
        
        // Here you would add SFTP upload logic
        // For now, just return success
        res.json({ 
            success: true, 
            message: 'Hugo site built successfully. SFTP upload would happen here.' 
        });
        
    } catch (error) {
        console.error('Upload error:', error);
        res.json({ 
            success: false, 
            message: `Upload failed: ${error.message}` 
        });
    }
});

// Preview blog endpoint
app.post('/api/preview-blog', (req, res) => {
    const config = getConfig();
    
    if (!config.hugoPath || !config.hugoPath.trim()) {
        return res.json({ 
            success: false, 
            message: 'Hugo path not configured. Please set it in Settings.' 
        });
    }
    
    try {
        const { exec } = require('child_process');
        
        // Start Hugo server in background
        const hugoCommand = `cd "${config.hugoPath}" && hugo server --bind 0.0.0.0 --port 1313 --disableFastRender`;
        
        exec(hugoCommand, (error, stdout, stderr) => {
            if (error && !error.message.includes('already in use')) {
                console.error('Hugo server error:', error);
            } else {
                console.log('Hugo server started on http://localhost:1313');
            }
        });
        
        res.json({ 
            success: true, 
            message: 'Hugo preview server started. It may take a moment to be ready.',
            url: 'http://localhost:1313'
        });
        
    } catch (error) {
        console.error('Preview error:', error);
        res.json({ 
            success: false, 
            message: `Preview failed: ${error.message}` 
        });
    }
});

// Start server
app.listen(PORT, () => {
    console.log(`
    ‚úÖ Blog Creator App is running!
    üìç Local: http://localhost:${PORT}
    
    ‚ö° New Features Added:
    1. Image upload and handling
    2. Spell/grammar correction
    
    Next steps:
    1. Visit http://localhost:${PORT}
    2. Configure settings at /settings
    3. Add your DeepSeek API key
    4. Start generating blogs!
    `);
});
